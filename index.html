<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handwritten Math Expression Recognition</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        /* Optional styling for the canvas */
        #canvas {
            border: 2px solid black;
            background-color: white;
        }
        #prediction {
            font-size: 20px;
            font-weight: bold;
            margin-top: 20px;
        }
    </style>
</head>
<body>

<h1>Draw a Math Expression!</h1>

<!-- Canvas for drawing -->
<canvas id="canvas" width="500" height="500"></canvas>
<p id="status">Loading Model...</p>

<p id="prediction">Prediction: </p>

<script>
    // Load the model from Google Cloud Storage
    async function loadModel() {
        try {
            const model = await tf.loadGraphModel('https://storage.googleapis.com/imrec/model.json');
            console.log('Model loaded successfully!');
            document.getElementById('status').innerText = 'Model Loaded. You can start drawing!';
            return model;
        } catch (error) {
            console.error('Error loading model:', error);
            document.getElementById('status').innerText = 'Failed to load the model. Please try again.';
        }
    }

    // Initialize the canvas and drawing functionality
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';

    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    // Handle mouse events for drawing
    canvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        lastX = e.offsetX;
        lastY = e.offsetY;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDrawing) {
            const x = e.offsetX;
            const y = e.offsetY;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
            lastX = x;
            lastY = y;
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDrawing = false;
        // Trigger recognition after drawing stops
        recognizeInput();
    });

    // Function to capture and preprocess the drawing
    async function recognizeInput() {
        // Capture the canvas image as a tensor
        const imageTensor = tf.browser.fromPixels(canvas);
        console.log('Original Image Tensor:');
        imageTensor.print();  // Print the tensor data to console

        // Check the image dimensions and content
        const imgData = imageTensor.dataSync();
        const nonZeroPixels = imgData.filter(value => value !== 0).length;
        console.log('Non-zero pixels:', nonZeroPixels);

        if (nonZeroPixels === 0) {
            console.log("No drawing detected.");
            return;
        }

        // Resize the image to 64x64 as required by your model
        const resizedImage = tf.image.resizeBilinear(imageTensor, [64, 64]);
        console.log('Resized Image Tensor:');
        resizedImage.print();  // Print the tensor data to console

        // Normalize the image and adjust for single channel (grayscale)
        const normalizedImage = resizedImage.div(255.0).expandDims(0).mean(2).expandDims(2); // Normalize and adjust the shape
        console.log('Normalized Image Tensor:');
        normalizedImage.print();  // Print the tensor data to console

        // Make a prediction with the model
        const prediction = await model.predict(normalizedImage);
        console.log('Prediction:', prediction);

        // Get the predicted class (for symbol-level classifier, assuming 7 classes)
        const predictedClass = prediction.argMax(-1).dataSync()[0];
        console.log('Predicted Class Index:', predictedClass);

        // Map the predicted class to its symbol (adjust this to your dataset)
        const classNames = ['!', '(', ')', '+', ',', '-', '0']; // Adjust based on your class labels
        const predictedSymbol = classNames[predictedClass];
        console.log('Predicted Symbol:', predictedSymbol);

        // Display the prediction
        document.getElementById('prediction').innerText = 'Prediction: ' + predictedSymbol;
    }

    // Start loading the model
    let model;
    loadModel().then((loadedModel) => {
        model = loadedModel;
    });
</script>
</body>
</html>
