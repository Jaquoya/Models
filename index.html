<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Handwritten Math Recognizer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
      background-color: #1e1e2f;
      color: #ffffff;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: crosshair;
    }

    #output {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 10px;
      font-size: 24px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="output">Draw something...</div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0"></script>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const outputDiv = document.getElementById("output");

    let isDrawing = false;
    let strokes = [];
    let currentStroke = [];

    // Resize canvas
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    ctx.lineWidth = 12;
    ctx.lineCap = "round";
    ctx.strokeStyle = "#ffffff";

    canvas.addEventListener("mousedown", e => {
      isDrawing = true;
      currentStroke = [];
      ctx.beginPath();
      ctx.moveTo(e.clientX, e.clientY);
      currentStroke.push([e.clientX, e.clientY]);
    });

    canvas.addEventListener("mousemove", e => {
      if (!isDrawing) return;
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
      currentStroke.push([e.clientX, e.clientY]);
    });

    canvas.addEventListener("mouseup", () => {
      if (isDrawing) {
        isDrawing = false;
        strokes.push(currentStroke);
        detectPause();
      }
    });

    let pauseTimer = null;
    function detectPause() {
      if (pauseTimer) clearTimeout(pauseTimer);
      pauseTimer = setTimeout(async () => {
        await recognizeSymbols();
        strokes = [];
      }, 1000); // 1 second pause
    }

    let model;
    async function loadModel() {
      const modelUrl = 'https://raw.githubusercontent.com/Jaquoya/Models/main/model.json'; // Ensure this URL points to the raw model file
      model = await tf.loadGraphModel(modelUrl);
      outputDiv.textContent = "Model loaded! Start drawing.";
    }

    async function recognizeSymbols() {
      if (!strokes.length) return;

      let symbols = [];
      for (const stroke of strokes) {
        const [minX, minY, maxX, maxY] = getBoundingBox(stroke);
        const symbolCanvas = document.createElement("canvas");
        const sCtx = symbolCanvas.getContext("2d");
        const size = 64;
        symbolCanvas.width = size;
        symbolCanvas.height = size;

        // Clear background
        sCtx.fillStyle = "#000";
        sCtx.fillRect(0, 0, size, size);

        // Scale and draw stroke
        sCtx.strokeStyle = "#fff";
        sCtx.lineWidth = 8;
        sCtx.lineCap = "round";
        sCtx.beginPath();

        const scaleX = size / (maxX - minX);
        const scaleY = size / (maxY - minY);
        const scale = Math.min(scaleX, scaleY) * 0.8;
        const offsetX = (size - (maxX - minX) * scale) / 2;
        const offsetY = (size - (maxY - minY) * scale) / 2;

        for (let i = 0; i < stroke.length; i++) {
          const [x, y] = stroke[i];
          const dx = (x - minX) * scale + offsetX;
          const dy = (y - minY) * scale + offsetY;
          if (i === 0) sCtx.moveTo(dx, dy);
          else sCtx.lineTo(dx, dy);
        }
        sCtx.stroke();

        const imgData = sCtx.getImageData(0, 0, size, size);
        const input = tf.browser.fromPixels(imgData, 1).toFloat().div(255).expandDims(0);
        const prediction = model.predict(input);
        const classId = prediction.argMax(-1).dataSync()[0];
        const classMap = ['0', '1', '2', '3', '4', '5', '6', '+', '-', '*', '/']; // customize as needed
        symbols.push(classMap[classId]);
        tf.dispose([input, prediction]);
      }

      const expr = symbols.join("");
      let result;
      try {
        result = eval(expr);
      } catch {
        result = "Invalid Expression";
      }
      outputDiv.textContent = `${expr} = ${result}`;
    }

    function getBoundingBox(stroke) {
      const xs = stroke.map(p => p[0]);
      const ys = stroke.map(p => p[1]);
      return [Math.min(...xs), Math.min(...ys), Math.max(...xs), Math.max(...ys)];
    }

    loadModel();
  </script>
</body>
</html>
